[{"id":0,"href":"/docs/get-started/","title":"Get Started","section":"Docs","content":" Get started # Requirements:\nDocker Go 1.22+ Optional:\nTilt Clone starter repository # git clone https://github.com/daarlabs/starter.git Start the app # tilt up # OR docker compose up Your app will be running on localhost\nNext step # Config\n"},{"id":1,"href":"/docs/packages/cli/","title":"CLI","section":"Docs","content":" CLI # Requirements # Go 1.22+ Get started # go install -v github.com/daarlabs/hrx\nCmd # Run hrx -h to see all possibilities\n"},{"id":2,"href":"/docs/packages/dyna/","title":"Dyna","section":"Docs","content":" Dyna # Dynamic data manager Supports manual provided data, database data or data factory functions Used in dynamic components like: autocomplete, datatable Database query uses Esquel New instance # dyna.New() Query data model # type Query struct { Table string Alias string Value string Fields map[string]string } Table # Database table name\nAlias # Datatable table alias\nValue # Datatable table field name, like id\nFields # Datatable fields aliases, suitable for smart components\nFields: map[string]string{ \u0026#34;text\u0026#34;: \u0026#34;e.name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;e.id\u0026#34;, } Set DB # m := dyna.New() m.DB(db, query) Set Data # m := dyna.New() m.Data([]map[string]any{ { \u0026#34;value\u0026#34;: 1, \u0026#34;text\u0026#34;: \u0026#34;Text 1\u0026#34; }, { \u0026#34;value\u0026#34;: 2, \u0026#34;text\u0026#34;: \u0026#34;Text 2\u0026#34; }, }) Parse params from hiro.Ctx # var param dyna.Param param = param.Parse(c) Use params on Esquel query # Generates conditions, sorting, offseting, limiting var param dyna.Param param = param.Parse(c) q := db.Q(`...`) param.Use(q) q.MustExec() Get data # Automatically choose data source (manual data / database), if override func exists, prefers that Get All # GetAll(param, \u0026amp;target) Get One # GetOne(\u0026#34;id\u0026#34;, 1, \u0026amp;target) Get Many # GetMany(\u0026#34;id\u0026#34;, []int{1,2,3}, \u0026amp;target) Override data get # Get All Func # GetAllFunc(func(param Param, t any) error { // ... return nil }) Get One Func # GetOneFunc(func(name string, v any, t any) error { // ... return nil }) Get Many Func # GetManyFunc(func(name string, v any, t any) error { // ... return nil }) Util # Create Select # // third param is not required, because id is default value field CreateSelect(\u0026#34;examples\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;id\u0026#34;) Query "},{"id":3,"href":"/docs/packages/esquel/","title":"Esquel","section":"Docs","content":" Esquel # Database abstraction layer Only supports Postgres, right now Connection # Use with Config\nfunc Postgres() *esquel.DB { return esquel.MustConnect( esquel.WithPostgres(), esquel.WithHost(\u0026#34;localhost\u0026#34;), esquel.WithPort(5432), esquel.WithDbname(\u0026#34;postgres\u0026#34;), esquel.WithUser(\u0026#34;postgres\u0026#34;), esquel.WithPassword(\u0026#34;postgres\u0026#34;), esquel.WithSslDisable(), esquel.WithLog(true), esquel.WithTimeout(esquel.DefaultTimeout), ) } Data model # By default, Esquel uses fields camelCase name transformed to snake_case Field name can be overriden with db tag Nullable fields need sql.Null[T] type For filling nullable fields, you can use esquel.Nullable[T any](value T) type Example struct { Id int FooBar string `db:\u0026#34;foo_bar\u0026#34;` Nullable sql.Null[string] } var data = Example{ Nullable: esquel.Nullable(\u0026#34;foo\u0026#34;), } Advice\nIf you have some relationship to another table with some id in your data model and it can be NULL, you have to use sql.Null[int64] RelationshipId sql.Null[int64] `db:\u0026#34;relationship_id\u0026#34;` Query # Query can be splitted in parts Each part can have own params func MustGetAll(db *esquel.DB) []model.Example { result := make([]model.Example, 0) db.Q(`SELECT *`). Q(`FROM examples`). Q(`WHERE category = @category`, esquel.Param{\u0026#34;category\u0026#34;: \u0026#34;foo\u0026#34;}). Q(`LIMIT 20`). MustExec(\u0026amp;result) return result } If # Query part will be used if condition is true func MustGetAll(db *esquel.DB, category string) []model.Example { result := make([]model.Example, 0) db.Q(`SELECT *`). Q(`FROM examples`). If( len(category) \u0026gt; 0, `WHERE category = @category`, esquel.Param{\u0026#34;category\u0026#34;: category}, ). Q(`LIMIT 20`). MustExec(\u0026amp;result) return result } Factory # Utils, which can help you to create INSERT or UPDATE fields and placeholders strings Create Insert # data := esquel.Param{ \u0026#34;first_name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;Bar\u0026#34;, \u0026#34;age\u0026#34;: 30, } fields, placeholders := CreateInsert(data) var id int db.Q(`INSERT INTO examples`). Q(\u0026#34;(\u0026#34; + fields + \u0026#34;)\u0026#34;). Q(\u0026#34;VALUES (\u0026#34; + placeholders + \u0026#34;)\u0026#34;, data). Q(\u0026#34;RETURNING id\u0026#34;). MustExec(\u0026amp;id) Create Update # data := esquel.Param{ \u0026#34;first_name\u0026#34;: \u0026#34;Bar\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;age\u0026#34;: 31, } db.Q(`UPDATE examples`). Q(\u0026#34;SET \u0026#34; + CreateUpdate(data), data). Q(\u0026#34;WHERE id = @id\u0026#34;, esquel.Map{\u0026#34;id\u0026#34;: 1}). MustExec(\u0026amp;id) In # Arrays are automatically recognized, no need of any additional operation IN is automatically transformed to ANY Where(`id IN (@ids)`, esquel.Param{\u0026#34;ids\u0026#34;: []int{1,2,3}}) Transactions # tx := db.MustBegin() if someError { tx.MustRollback() return } tx.MustCommit() Postgres Type # Jsonb # Esquel custom type You can transform map to jsonb with MapToJsonb type Example struct { SomeMap Jsonb[string] } var data = Example{ SomeMap: esquel.MapToJsonb(map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;,\t}) } Postgres Utils # CreateTsVector # Create tsvector values from any primitive type\nWhere( \u0026#34;INSERT INTO examples (vectors) VALUES (to_tsvector(@vectors))\u0026#34;, esquel.Param{\u0026#34;vectors\u0026#34;: esquel.CreateTsVector(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)}, ) CreateTsQuery # Create tsquery values from any primitive type\nWhere( \u0026#34;vectors @@ to_tsquery(@tsquery)\u0026#34;, esquel.Param{\u0026#34;tsquery\u0026#34;: esquel.CreateTsQuery(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)}, ) "},{"id":4,"href":"/docs/packages/form/","title":"Form","section":"Docs","content":" Form # Logic form layer Advice\nUse import alias import . \u0026ldquo;github.com/daarlabs/hirokit/form\u0026rdquo; Data model # type BookForm struct { Form Name Field[string] Chapters Field[int] Pages Field[int] Read Field[bool] Demo Field[Multipart] Published Field[time.Time] } Factory # Name and Id can be different Field types are named by HTML Hiro form factory generates all necessary, but you can customize it with chaining methods func CreateBookForm(c hiro.Ctx) (BookForm, error) { f := c.Create().Form( Add(\u0026#34;name\u0026#34;).Id(\u0026#34;name\u0026#34;).Label(\u0026#34;Name\u0026#34;).With(Text(), Validate.Required()), Add(\u0026#34;chapters\u0026#34;).Id(\u0026#34;chapters\u0026#34;).Label(\u0026#34;Chapters\u0026#34;).With(Number[int](), Validate.Required()), Add(\u0026#34;pages\u0026#34;).Id(\u0026#34;pages\u0026#34;).Label(\u0026#34;Pages\u0026#34;).With(Number[int](),Validate.Required()), Add(\u0026#34;read\u0026#34;).Id(\u0026#34;read\u0026#34;).Label(\u0026#34;Read\u0026#34;).With(Checkbox()), Add(\u0026#34;demo\u0026#34;).Id(\u0026#34;demo\u0026#34;).Label(\u0026#34;Demo\u0026#34;).With(File()), Add(\u0026#34;published\u0026#34;).Id(\u0026#34;published\u0026#34;).Label(\u0026#34;Published\u0026#34;).With(Time()), ) return Build[BookForm](f) } Advice\nYou can create Must func func MustCreateBookForm(c hiro.Ctx) BookForm { f, err := CreateBook(c) if err != nil { panic(err) } return f } Default value # // Let\u0026#39;s say, you have some select and // you need number value and string text // on detail page Add(\u0026#34;name\u0026#34;). Id(\u0026#34;name\u0026#34;). Label(\u0026#34;Name\u0026#34;). Text(\u0026#34;some text\u0026#34;). With( Number[int](someValue), Validate.Required(), ) Advice\nFor simplify view layer, create field props factory type TextFieldProps struct { Id string Name string Label string Value string Placeholder string Messages []string Autofocus bool Disabled bool Required bool } func CreateProps(field form.Field[string]) TextFieldProps { return TextFieldProps{ Id: field.Id, Name: field.Name, Label: field.Label, Value: field.Value, Messages: field.Messages, Disabled: field.Disabled, Autofocus: field.Autofocus, Required: field.Required, } } "},{"id":5,"href":"/docs/packages/gox/","title":"Gox","section":"Docs","content":" Gox # HTML knowledge required Composable pure function view layer You can use any HTML element as Go func Advice\nUse import alias import . \u0026ldquo;github.com/daarlabs/hirokit/gox\u0026rdquo; Be careful with naming convention to prevent HTML nodes names collisions Sample code # package app import ( . \u0026#34;github.com/daarlabs/hirokit/gox\u0026#34; ) func Page() string { return Render( Html( Lang(\u0026#34;en\u0026#34;), Head( Title(Text(\u0026#34;Example app\u0026#34;)), ), Body( H1(Text(\u0026#34;Example page\u0026#34;)), P(Text(\u0026#34;Example paragraph\u0026#34;)), ), ), ) } Render # Render function transform Gox nodes to string\nRender( Div(Text(\u0026#34;Gox\u0026#34;)) ) Text # For the composition feature, we need to use text node, instead of primitive string\nH1(Text(\u0026#34;Headline 1\u0026#34;)) P(Text(\u0026#34;Paragraph\u0026#34;)) Elements # Div() H1() P() Attributes # Button( Type(\u0026#34;submit\u0026#34;), CustomData(\u0026#34;track\u0026#34;, \u0026#34;submit-button\u0026#34;), ) A( Href(\u0026#34;/\u0026#34;), Text(\u0026#34;Go to homepage\u0026#34;), ) Shared # Some nodes have shared name (label, style, title, \u0026hellip;) Modifiers Element(), Attribute() will change node type Label(Text(\u0026#34;E-mail\u0026#34;)) Style(Element(), Raw(\u0026#34;body{background:red;}\u0026#34;)) Fragment # Wrapper, when you need group nodes to single node\nFragment( Div(), Span(), H1(), ) Write # If you have io.Writer, like http.ResponseWriter, you can use Write(w io.Writer, nodes \u0026hellip;Node) function\nWrite(w, Div(Text(\u0026#34;this is the response\u0026#34;))) Append # After node initialization, you can append nodes to the node\nAppend( Div(), Text(\u0026#34;Appended node\u0026#34;), ) Raw # Pure HTML can be used with Raw() node\nRaw(`\u0026lt;div\u0026gt;Raw element\u0026lt;/div\u0026gt;`) Factory # If some element, attribute missing, or you have some custom features, you can create you own Gox nodes\nCustomElement := CreateElement(\u0026#34;my-custom-element\u0026#34;) CustomAttribute := CreateAttribute[string](\u0026#34;my-custom-attribute\u0026#34;) CustomElement( CustomAttribute(\u0026#34;some-value\u0026#34;), ) Plugin # You can also create custom nodes, as struct, with only one required method Node() Node\ntype MyPlugin struct { SomeValue string } func (p MyPlugin) Node() Node { return Div( Text(p.SomeValue) ) } Clsx # Built-in plugin to conditional classes\nDiv( Clsx{ \u0026#34;class-1 class-2\u0026#34;: true, \u0026#34;class-3\u0026#34;: false, } ) Component # Gox offers compose power to create stateless UI components\nfunc MainButton(content string) Node { return Button( Type(\u0026#34;button\u0026#34;), CustomData(\u0026#34;test\u0026#34;, \u0026#34;test-id\u0026#34;), Text(content), ) } "},{"id":6,"href":"/docs/packages/hiro/","title":"Hiro","section":"Docs","content":" Hiro # Robust full-stack framework for highly interactive web applications\n"},{"id":7,"href":"/docs/packages/hiro/assets/","title":"Assets","section":"Hiro","content":" Assets # "},{"id":8,"href":"/docs/packages/hiro/auth/","title":"Auth","section":"Hiro","content":" Auth # "},{"id":9,"href":"/docs/packages/hiro/cache/","title":"Cache","section":"Hiro","content":" Cache # "},{"id":10,"href":"/docs/packages/hiro/component/","title":"Component","section":"Hiro","content":" Component # "},{"id":11,"href":"/docs/packages/hiro/config/","title":"Config","section":"Hiro","content":" Config # App # App: config.App{ Name: \u0026#34;your-app-name\u0026#34;, Plugin: true // If it\u0026#39;s plugin, not an app PublicUrlPath: \u0026#34;/public/\u0026#34;, PublicLocalDir: \u0026#34;./public/\u0026#34;, } Plugin # Plugins like Farah UI, based on Hiro, must be registered, they need set the field to true\nCache # Cache by default uses memory package, but recommended way is to use Redis (or Redis-compatible database) Redis client Cache: config.Cache{ // Custom memory dir, which persist cache state memory: memory.New(\u0026#34;./custom-backup-dir\u0026#34;), redis: redis.NewClient( \u0026amp;redis.Options{ Addr: \u0026#34;starter-redis:6379\u0026#34;, DB: 1, }, ) } Database # Supports multi-database system Main database is default Provided naming convention constant Database: map[string]*esquel.DB{ hiro.Main: MainDatabase(), \u0026#34;some-database\u0026#34;: SomeAnotherDatabase(), }, Form # Limit incoming form data size in MBs Form: form.Config{ Limit: 256, } Filesystem # Local S3-compatible - Minio client // Local Filesystem: filesystem.Config{ Driver: filesystem.Local, Dir: \u0026#34;./files\u0026#34; } // Cloud cloudClient, _ := minio.New( \u0026#34;your-bucket-endpoint\u0026#34;, \u0026amp;minio.Options{ Creds: credentials.NewStaticV4( \u0026#34;your-bucket-access-key\u0026#34;, \u0026#34;your-bucket-secret-key\u0026#34;, \u0026#34;\u0026#34;, // token, if necessary ), Secure: true, }, ) Filesystem: filesystem.Config{ Driver: filesystem.Cloud, Cloud: cloudClient, Name: \u0026#34;my-bucket-name\u0026#34; } Localization # Uses cookies by default Can use path prefix Localization: config.Localization{ Enabled: true, // If you want have lang code as path prefix Path: true, Languages: []config.Language{ { Main: true, Code: \u0026#34;cs\u0026#34; }, { Code: \u0026#34;en\u0026#34; }, }, Translator: translator.New( translator.Config{ Dir: \u0026#34;./locales\u0026#34;, FileType: translator.Yaml, }, ), Form: form.Messages{ Email: \u0026#34;error.form.field.email\u0026#34;, Required: \u0026#34;error.form.field.required\u0026#34;, MinText: \u0026#34;error.form.field.min-text\u0026#34;, MaxText: \u0026#34;error.form.field.max-text\u0026#34;, MinNumber: \u0026#34;error.form.field.min-number\u0026#34;, MaxNumber: \u0026#34;error.form.field.max-number\u0026#34;, }, } Parser # Limit incoming body size (files) in MBs, when you are not using form builder Parser: config.Parser{ Limit: 256, } Router # Router: config.Router{ // If you want have in all paths prefix, // lang code included, but has more weight Prefix: \u0026#34;custom-prefix\u0026#34;, // Automatic panic recover // Handled by dynamic handler Recover: true, } Security # Auth and firewall are two different packages, each manage their own things, but roles must be shared\nroles := []auth.Role{ {Name: \u0026#34;super-admin\u0026#34;, Super: true}, } Security: config.Security{ Auth: auth.Config{ Roles: roles, }, Csrf: csrf.New(), Firewall: []firewall.Firewall{ { Enabled: true, Name: hiro.Main, Roles: roles, Groups: []string{\u0026#34;super-secret-page\u0026#34;}, Redirect: \u0026#34;login\u0026#34;, // If forbidden, route name redirect }, }, } Firewall # Comparing names and securables Roles # One has to be main Super has access through all firewalls, despite firewall securables Groups # Universally named paths names prefixes CSRF # If CSRF has config instance, it\u0026rsquo;s auto-injected, through factory to all forms, when you are not logged in Smtp # Smtp: mailer.Config{ Host: \u0026#34;your-host\u0026#34;, Port: 25, User: \u0026#34;username\u0026#34;, Password: \u0026#34;password\u0026#34;, From: \u0026#34;\\\u0026#34;Your Name\\\u0026#34; \u0026lt;info@your-email.com\u0026gt;\u0026#34;, } Previous step # Get started\nNext step # Router\n"},{"id":12,"href":"/docs/packages/hiro/context/","title":"Context","section":"Hiro","content":" Context # "},{"id":13,"href":"/docs/packages/hiro/context/component/","title":"Component","section":"Context","content":" Context - Component # "},{"id":14,"href":"/docs/packages/hiro/context/factory/","title":"Factory","section":"Context","content":" Context - Factory # "},{"id":15,"href":"/docs/packages/hiro/context/flash-message/","title":"Flash Message","section":"Context","content":" Context - Flash Message # "},{"id":16,"href":"/docs/packages/hiro/context/generator/","title":"Generator","section":"Context","content":" Context - Generator # "},{"id":17,"href":"/docs/packages/hiro/context/interceptor/","title":"Interceptor","section":"Context","content":" Interceptor # "},{"id":18,"href":"/docs/packages/hiro/context/page/","title":"Page","section":"Context","content":" Context - Page # "},{"id":19,"href":"/docs/packages/hiro/context/request/","title":"Request","section":"Context","content":" Request # "},{"id":20,"href":"/docs/packages/hiro/context/request/is/","title":"Is","section":"Request","content":" Request - Is # "},{"id":21,"href":"/docs/packages/hiro/context/response/","title":"Response","section":"Context","content":" Response # "},{"id":22,"href":"/docs/packages/hiro/context/state/","title":"State","section":"Context","content":" Context - State # "},{"id":23,"href":"/docs/packages/hiro/cookies/","title":"Cookies","section":"Hiro","content":" Cookies # "},{"id":24,"href":"/docs/packages/hiro/csrf/","title":"Csrf","section":"Hiro","content":" CSRF # "},{"id":25,"href":"/docs/packages/hiro/database/","title":"Database","section":"Hiro","content":" Database # "},{"id":26,"href":"/docs/packages/hiro/filesystem/","title":"Filesystem","section":"Hiro","content":" Filesystem # "},{"id":27,"href":"/docs/packages/hiro/firewall/","title":"Firewall","section":"Hiro","content":" Firewall # "},{"id":28,"href":"/docs/packages/hiro/handler/","title":"Handler","section":"Hiro","content":" Handler # "},{"id":29,"href":"/docs/packages/hiro/layout/","title":"Layout","section":"Hiro","content":" Layout # "},{"id":30,"href":"/docs/packages/hiro/localization/","title":"Localization","section":"Hiro","content":" Localization # "},{"id":31,"href":"/docs/packages/hiro/mailer/","title":"Mailer","section":"Hiro","content":" Mailer # "},{"id":32,"href":"/docs/packages/hiro/middleware/","title":"Middleware","section":"Hiro","content":" Middleware # "},{"id":33,"href":"/docs/packages/hiro/plugin/","title":"Plugin","section":"Hiro","content":" Plugin # "},{"id":34,"href":"/docs/packages/hiro/router/","title":"Router","section":"Hiro","content":" Router # "},{"id":35,"href":"/docs/packages/hiro/view/","title":"View","section":"Hiro","content":" View # "},{"id":36,"href":"/docs/packages/tempest/","title":"Tempest","section":"Docs","content":" Tempest # On-request dynamic styles utility-based framework CSS, JS, Fonts manager API inspired by TailwindCSS Classes and their styles are cached Config # Tempest uses global config and sync.Map to store classes, so you need to configure it before app config initialization Advice\nInit Tempest Config in same file as an app config func init() { tempest.GlobalConfig = \u0026amp;tempest.Config{ // App font family FontFamily: \u0026#34;Sora, sans-serif\u0026#34;, // Aditional fonts Font: map[string]tempest.Font{ \u0026#34;sora\u0026#34;: { Value: \u0026#34;Sora, sans-serif\u0026#34;, Url: \u0026#34;https://fonts.googleapis.com/css2?family=Sora:wght@100..800\u0026amp;display=swap\u0026#34;, }, }, // Additional styles, which will be bundled Styles: []string{ \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css\u0026#34;, }, // Scripts to bundle Scripts: []string{ \u0026#34;https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\u0026#34;, \u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;, }, // Custom colors Color: map[string]tempest.Color{ palette.Primary: palette.PrimaryPallete, }, // Custom shadows Shadow: map[string][]tempest.Shadow{ \u0026#34;focus\u0026#34;: { { Value: \u0026#34;0 0 0 0.25rem\u0026#34;, Hex: palette.PrimaryPallete[400], Opacity: 15, }, }, }, } tempest.Start() } Start # Process and prepare all necessary things to provide frontend assets\nAssets providing # By default, Hiro has routes for dynamic Tempest content, so you don\u0026rsquo;t need to worry about that\nClass # tempest.Class() is factory, which create gox.Node class element or string Use methods chaining to apply all classes, you want to Warning\nNot all classes have been implemented yet Div( tempest.Class().P(1).M(1).TextSlate(900).TextWhite(tempest.Dark()) ), Component Action # If you use tempest.Class() in smart component action response, you have to add .Name(c.Request().Action()) Actions are dynamic and Tempest doesn\u0026rsquo;t use request context, so they are stored by action name Not cached classes are dynamically added to response tempest.Class().Name(c.Request().Action()).BgSlate(100).P(4) Modifier # Placeholder # tempest.Class().TextSlate(900).TextSlate(400, tempest.Placeholder()) Dark # Classes with Dark() modifier will be used, if any parent has dark class\ntempest.Class().BgWhite().BgSlate(900, tempest.Dark()) Advice\nYou can store dark mode in cookies and use dark in body class Body( Clsx{ tempest.Class().Dark(): c.Cookie.Get(\u0026#34;X-Dark-Mode\u0026#34;) == \u0026#34;true\u0026#34;, } ) Hover # tempest.Class().BgSlate(400).BgBlue(400, tempest.Hover()) Focus # tempest.Class().Border(1).BorderSlate(300).BorderBlue(400, tempest.Focus()) Checked # tempest.Class(). BgWhite().BgBlue(400, tempest.Checked()) Border(1).BorderSlate(300).BorderBlue(400, tempest.Checked()) Peer # tempest.Class(). BgWhite().BgBlue(400, tempest.Checked(tempest.Peer)) Border(1).BorderSlate(300).BorderBlue(400, tempest.Checked(tempest.Peer)) Group # tempest.Class().BgWhite().BgBlue(400, tempest.Hover(tempest.Group)) Opacity # tempest.Class().BgSlate(900, tempest.Opacity(80)) Media query # tempest.Class(). W(4). W(8, tempest.Xs()). W(12, tempest.Sm()). W(16, tempest.Md()). W(24, tempest.Lg()). W(32, tempest.Xl()). W(64, tempest.Xxl()) "}]